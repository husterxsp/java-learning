学习JVM-java内存结构

《深入理解java虚拟机》第2章阅读

### 2.1 概述

C/C++ 开发时需要担负着资源对象从开始到终结的维护工作，但是Java不需要写 `delete/free` 代码，因为java 虚拟机有自动内存管理机制，不容易出现内存泄漏和内存溢出的问题。

### 2.2 运行时数据区域

java 运行时会把管理的内存分为几个不同的数据区，这些区域有不同的用途及创建和销毁时间。

#### 2.2.1 程序计数器

一小块内存，可以看做当前线程所执行的字节码的行号指示器。虚拟机的字节码解释器通过改变这个程序计数器来选取下一条需要执行的字节码指令。
由于java的多线程是轮转时间片，所以这个计数器是线程私有的。

如果是java方法，该计数器记录正在执行虚拟机字节码指令地址，如果是native方法？值为空。

此内存区域是唯一一个没有规定任何OutOfMemoryError错误的内存区域。


#### 2.2.2 Java虚拟机栈

线程私有，虚拟机栈是Java方法运行时的内存模型：每个方法运行时都会创建一个基础数据结构（栈帧，即放在虚拟机栈中的一个元素），用来存储一些局部变量等。方法调用的过程就是栈帧在虚拟机栈中入栈和出栈的过程。

如果简单的划分java内存为 堆内存 和 栈内存。那么这个栈内存就是指虚拟机栈。

局部变量表存放基本数据类型，对象引用类型，和 returnAddress。

其中64位的long和double占两个局部变量空间。

Java虚拟机规范对这个区域规定的异常：
- StackOverflow：线程请求的栈深度大于虚拟机允许的深度。
- OutOfMemoryError: 动态扩展虚拟机栈时，内存不足。

#### 2.2.3 本地方法栈

为 native 方法服务。

#### 2.2.4 Java堆

被所有线程共享。所有的对象实例以及数组都要在堆上分配（不绝对）。

是垃圾收集管理器的主要区域，也被称为“GC堆”（garbage Collection Heap）。

从垃圾回收的角度，由于现在收集器基本采用分代收集，所以java堆可以细分为 新生代和老生代。
从内存分配的角度，可能划分出线程私有的分配缓冲区。

#### 2.2.5 方法区

线程共享。用于存储类信息、常量、静态变量、及时编译后的代码等数据。

永久代？


#### 2.2.6 运行时常量池

方法区的一部分。用于存放编译期生成的各种字面量和符号引用。

#### 2.2.7 直接内存

NIO

### 2.3 HotSpot 虚拟机对象

#### 2.3.1 对象的创建

虚拟机遇到new指令先去常量池检查有没有某个类的引用，如果没有，执行类加载。

为新对象分配内存的两种方式：
- 指针碰撞：java堆中内存规整，那分配内存仅仅是把指针向空闲内存那边移动与新对象大小相等的距离。
- 空闲列表：java堆中内存交错，那需要维护一个表记录哪些内存块可用，在分配的时候找一个足够大的块分给对象实例。

具体用哪种方式取决于java堆内存是否规整，而这个是否规整取决于垃圾回收器是否有压缩整理功能。

对象创建很频繁，如果是移动指针，可能会有多个线程同时操作，有线程安全性的问题。两种解决办法：
- 同步（不懂）
- 本地线程分配缓存。即先用线程私有的空间，用完了需要分配新的私有空间时，再用同步锁定。

#### 2.3.2 对象的内存布局

分为三块：对象头、实例数据、对齐填充

对象头：
- 存储运行时数据，如hashcode等
- 类型指针，通过这个指针确定是哪个类的实例

实例数据
- 程序代码中定义的各种类型的字段信息。

对齐填充
- 不必然存在，也无特殊含义，仅起占位符的作用。
- HotSpot的内存管理要求对象起始地址是8的整数倍，因而如果实例数据导致数据没对齐（对象头是对齐的），可以通过对齐填充来补全。

#### 2.3.3 对象的访问定位

通过栈上的引用来操作堆上的具体对象。
访问对象的两种方式：
- 句柄：堆中划分一块作为句柄池，应用存储的是句柄地址，句柄包含对象实例数据和类型数据的地址。
- 使用直接指针访问：引用存储的就是对象地址。


使用句柄的好处：稳定的句柄地址，在对象改变时，只需要改变句柄中的实例数据指针，不需改变引用。
使用指针的好处：速度快，省去一次指针定位的开销。


### 2.4 OutMemoryError 异常

#### 2.4.1 java堆溢出

```java
/**
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {

	static class OOMObject {
	}

	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<OOMObject>();

		while (true) {
			list.add(new OOMObject());
		}
	}
}
// java.lang.OutOfMemoryError: Java heap space
```

可能的两种情况：内存泄漏、内存溢出。

#### 2.4.2 虚拟机栈和本地方法栈溢出

- StackOverflowError：递归调用的函数层次太深。
- OutOfMemoryError: 操作系统为每个进程分配的内存有限制，如果不停地创建线程，则可能把内存耗尽。

#### 2.4.3 方法区和运行时常量池溢出
什么是native 方法？

#### 2.4.4 本机直接内存溢出
